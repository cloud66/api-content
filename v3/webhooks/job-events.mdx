---
title: Job & Automation Events
---

# Job & Automation Events

Job and automation events are webhooks triggered by scheduled job executions, autoscaling operations, and automated infrastructure management activities.

## Scheduled Job Events

### `job.fail`
Triggered when a scheduled job execution fails.

**Payload includes:**
- Job information and configuration
- Execution failure details

```json
{
  "timestamp": 1640995200,
  "event_type": "job.fail",
  "job": {
    "uid": "job123abc456",
    "name": "daily-cleanup",
    "command": "rake cleanup:old_logs",
    "run_on": "rails",
    "server_uid": "123123123123123123",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T12:30:45Z"
  },
  "run_data": "Error: Permission denied accessing /var/log/cleanup"
}
```

### `job.backon`
Triggered when a previously failing job executes successfully.

**Payload includes:**
- Job information
- Success confirmation details

```json
{
  "timestamp": 1640995200,
  "event_type": "job.backon",
  "job": {
    "uid": "job123abc456",
    "name": "daily-cleanup",
    "command": "rake cleanup:old_logs",
    "run_on": "rails",
    "server_uid": "123123123123123123"
  }
}
```

## Autoscaling Events

### `autoscaling.failed`
Triggered when an autoscaling operation fails to complete.

**Payload includes:**
- Stack information
- Scaler configuration and failure details

```json
{
  "timestamp": 1640995200,
  "event_type": "autoscaling.failed",
  "uid": "abc123def456",
  "name": "My Application",
  "environment": "production",
  "scaler": {
    "server_group": "web",
    "metric": "cpu_usage_active",
    "min_count": 1,
    "max_count": 10,
    "scale_up_threshold": 80,
    "scale_down_threshold": 30
  }
}
```

### `autoscaling.actions`
Triggered when autoscaling successfully performs scaling actions (scale up or down).

**Payload includes:**
- Stack information
- Scaler details
- Action message describing what was done

```json
{
  "timestamp": 1640995200,
  "event_type": "autoscaling.actions",
  "uid": "abc123def456",
  "name": "My Application",
  "environment": "production",
  "scaler": {
    "server_group": "web",
    "metric": "cpu_usage_active",
    "current_count": 5,
    "target_count": 7,
    "action": "scale_up"
  },
  "action_message": "Scaled up from 5 to 7 servers due to high CPU usage (85%)"
}
```

## Common Use Cases

### Job Monitoring
- **Failure Alerts**: Get notified when critical jobs fail
- **Performance Tracking**: Monitor job execution times and success rates
- **Dependency Management**: Track job dependencies and execution order
- **Maintenance Scheduling**: Plan maintenance windows based on job schedules

### Autoscaling Management
- **Capacity Monitoring**: Track scaling events and resource utilization
- **Cost Optimization**: Monitor scaling patterns for cost analysis
- **Performance Tuning**: Adjust scaling thresholds based on actual usage
- **Incident Response**: Correlate scaling events with performance issues

### Operational Intelligence
- **Resource Planning**: Use scaling data for capacity planning
- **Alert Correlation**: Connect job failures with infrastructure issues
- **SLA Monitoring**: Track job execution against service level agreements
- **Automation Health**: Monitor the health of automated systems

## Event Response Patterns

### Job Failure Recovery
```json
{
  "event_type": "job.fail",
  "job": {
    "name": "database-backup",
    "command": "pg_dump production"
  },
  "run_data": "Connection refused"
}
```
**Typical responses:**
- Check database server health
- Retry job execution after delay
- Switch to backup database for job execution
- Alert database administrator if retries fail

### Autoscaling Optimization
```json
{
  "event_type": "autoscaling.actions",
  "action_message": "Scaled up from 2 to 8 servers due to high CPU usage (95%)"
}
```
**Typical responses:**
- Analyze traffic patterns causing scale-up
- Adjust scaling thresholds if needed
- Investigate application performance issues
- Update capacity planning forecasts

## Monitoring Strategies

### Job Health Monitoring
- Set up alerts for critical job failures
- Track job execution patterns and timing
- Monitor job dependencies and chains
- Maintain job execution logs and history

### Autoscaling Analytics
- Monitor scaling frequency and patterns
- Track resource utilization vs. scaling actions
- Analyze scaling delays and response times
- Optimize scaling policies based on data

### Integration Examples

```javascript
// Example: Job failure escalation
function handleJobFailure(webhook) {
  const job = webhook.job;
  
  if (job.name.includes('backup')) {
    // Critical backup job failed
    alertOpsTeam('URGENT: Backup job failed', webhook.run_data);
    scheduleBackupRetry(job, 15); // Retry in 15 minutes
  } else {
    // Non-critical job failed
    logJobFailure(job, webhook.run_data);
    scheduleRetry(job, 60); // Retry in 1 hour
  }
}

// Example: Autoscaling cost tracking
function trackScalingCosts(webhook) {
  if (webhook.event_type === 'autoscaling.actions') {
    const scaler = webhook.scaler;
    const costImpact = calculateCostDelta(
      scaler.current_count, 
      scaler.target_count
    );
    
    updateCostForecast(webhook.uid, costImpact);
    logScalingEvent(webhook);
  }
}
```

<Callout type="info" title="Job Event Timing">
Job events are generated after job execution completes, whether successful or failed. For long-running jobs, there may be a delay between job start and webhook delivery.
</Callout>

<RelatedModels models={['Job', 'Stack', 'Server']} />